//! Tuple space (Cartesian product)
#![allow(clippy::type_complexity)] // Complexity generated by the impl_for_tuples macro
use super::{ElementRefInto, FiniteSpace, SampleSpace, Space};
use crate::logging::Loggable;
use impl_trait_for_tuples::impl_for_tuples;
use rand::distributions::Distribution;
use rand::Rng;
use std::array::IntoIter;
use std::fmt;

/// A Cartesian product of spaces.
#[derive(Debug, Default, Clone, PartialEq, Eq)]
pub struct ProductSpace<T>(T);

impl<T> ProductSpace<T> {
    /// Initialize from a tuple of spaces.
    pub const fn new(spaces: T) -> Self {
        Self(spaces)
    }
}

impl<T: DisplayForTuple> fmt::Display for ProductSpace<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl<T: SpaceForTuples> Space for ProductSpace<T> {
    type Element = <T as SpaceForTuples>::Element;

    fn contains(&self, value: &Self::Element) -> bool {
        self.0.contains(value)
    }
}

impl<T: FiniteSpaceForTuples> FiniteSpace for ProductSpace<T> {
    fn size(&self) -> usize {
        self.0.size()
    }

    fn to_index(&self, element: &Self::Element) -> usize {
        self.0.to_index(element)
    }

    fn from_index(&self, index: usize) -> Option<Self::Element> {
        self.0.from_index(index)
    }

    fn from_index_unchecked(&self, index: usize) -> Option<Self::Element> {
        self.0.from_index_unchecked(index)
    }
}

impl<T> Distribution<<Self as Space>::Element> for ProductSpace<T>
where
    T: SpaceForTuples + SampleSpaceForTuples,
{
    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> <Self as Space>::Element {
        self.0.sample(rng)
    }
}

impl<T: SpaceForTuples> ElementRefInto<Loggable> for ProductSpace<T> {
    fn elem_ref_into(&self, _element: &Self::Element) -> Loggable {
        Loggable::Nothing
    }
}

// The impl_trait_for_tuples crate helps with implementing traits for tuples.
// I use custom versions of the space traits so that `ProductSpace`
// will only be generic over the tuples defined here.
// Otherwise,
//  * ProductSpace would be generic over any space, not just tuples
//  * Tuples would be interpred as spaces.
//      Could cause confusion given that not typical traits (Distribution) are implemented.
//      Could also cause a tuple of spaces to be accidentally interpreted as a product space.
//
// These have to be listed as public because they are part of the interface of ProductSpace
// but they are not intended to be implemented by user types.

/// Private.
pub trait DisplayForTuple {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result;
}

/// Private. Use [`Space`] instead.
pub trait SpaceForTuples {
    type Element;
    fn contains(&self, value: &Self::Element) -> bool;
}

/// Private. Use [`FiniteSpace`] instead.
pub trait FiniteSpaceForTuples: SpaceForTuples {
    fn size(&self) -> usize;
    fn to_index(&self, element: &Self::Element) -> usize;
    fn from_index(&self, index: usize) -> Option<Self::Element>;
    fn from_index_unchecked(&self, index: usize) -> Option<Self::Element>;
}

/// Private. Use [`Distribution`] instead.
pub trait SampleSpaceForTuples: SpaceForTuples {
    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> <Self as SpaceForTuples>::Element;
}

impl SpaceForTuples for () {
    type Element = ();

    fn contains(&self, _value: &Self::Element) -> bool {
        true
    }
}

#[impl_for_tuples(1, 12)]
#[tuple_types_custom_trait_bound(Space)]
impl SpaceForTuples for Tuple {
    for_tuples!( type Element = ( #( Tuple::Element ),* ); );

    fn contains(&self, value: &Self::Element) -> bool {
        for_tuples!( #( self.Tuple.contains(&value.Tuple) )&* )
    }
}

impl FiniteSpaceForTuples for () {
    fn size(&self) -> usize {
        1
    }

    fn to_index(&self, _element: &Self::Element) -> usize {
        0
    }

    fn from_index(&self, index: usize) -> Option<Self::Element> {
        if index == 0 {
            Some(())
        } else {
            None
        }
    }

    fn from_index_unchecked(&self, _index: usize) -> Option<Self::Element> {
        Some(())
    }
}

#[impl_for_tuples(1, 12)]
#[tuple_types_custom_trait_bound(FiniteSpace)]
impl FiniteSpaceForTuples for Tuple {
    fn size(&self) -> usize {
        for_tuples!( #( self.Tuple.size() )** )
    }

    fn to_index(&self, element: &Self::Element) -> usize {
        let mut index: usize = 0;
        for_tuples!( #(
            index *= self.Tuple.size();
            index += self.Tuple.to_index(&element.Tuple);
        )* );
        index
    }

    fn from_index(&self, mut index: usize) -> Option<Self::Element> {
        let sizes = [for_tuples!( #( self.Tuple.size() ),* )];
        let mut indices = [for_tuples!(#(0),*)];
        for (index_part, &size) in indices.iter_mut().rev().zip(sizes.iter().rev()) {
            *index_part = index % size;
            index /= size;
        }
        if index != 0 {
            return None;
        }

        let mut indices_iter = IntoIter::new(indices);
        Some(for_tuples!( ( #( self.Tuple.from_index(indices_iter.next().unwrap())? ),* ) ))
    }

    fn from_index_unchecked(&self, mut index: usize) -> Option<Self::Element> {
        self.from_index(index)
    }
}

impl SampleSpaceForTuples for () {
    fn sample<R: Rng + ?Sized>(&self, _rng: &mut R) -> Self::Element {}
}

#[impl_for_tuples(1, 12)]
#[tuple_types_custom_trait_bound(SampleSpace)]
impl SampleSpaceForTuples for Tuple {
    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::Element {
        for_tuples!( ( #( self.Tuple.sample(rng) ),* ) )
    }
}

#[cfg(test)]
#[allow(clippy::needless_pass_by_value)]
mod space {
    use super::super::{testing, IndexSpace};
    use super::*;
    use rstest::{fixture, rstest};

    type IndexTriple = ProductSpace<(IndexSpace, IndexSpace, IndexSpace)>;

    #[fixture]
    const fn index_314() -> IndexTriple {
        ProductSpace::new((IndexSpace::new(3), IndexSpace::new(1), IndexSpace::new(4)))
    }

    #[rstest]
    fn index_triple_contains_zero(index_314: IndexTriple) {
        assert!(index_314.contains(&(0, 0, 0)));
    }

    #[rstest]
    fn index_triple_contains_nonzero(index_314: IndexTriple) {
        assert!(index_314.contains(&(2, 0, 1)));
    }

    #[rstest]
    fn index_triple_size(index_314: IndexTriple) {
        assert_eq!(index_314.size(), 12);
    }

    #[rstest]
    fn index_triple_contains_samples(index_314: IndexTriple) {
        testing::check_contains_samples(&index_314, 100);
    }

    type UnitSpace = ProductSpace<()>;

    #[test]
    fn unit_contains_unit() {
        let space = UnitSpace::new(());
        assert!(space.contains(&()));
    }

    #[test]
    fn unit_contains_samples() {
        let space = UnitSpace::new(());
        testing::check_contains_samples(&space, 10);
    }
}

#[cfg(test)]
#[allow(clippy::needless_pass_by_value)]
mod finite_space {
    use super::super::{testing, IndexSpace};
    use super::*;
    use rstest::{fixture, rstest};

    type IndexTriple = ProductSpace<(IndexSpace, IndexSpace, IndexSpace)>;

    #[fixture]
    const fn index_314() -> IndexTriple {
        ProductSpace::new((IndexSpace::new(3), IndexSpace::new(1), IndexSpace::new(4)))
    }

    #[rstest]
    fn index_triple_to_index_zeros(index_314: IndexTriple) {
        assert_eq!(index_314.to_index(&(0, 0, 0)), 0);
    }

    #[rstest]
    fn index_triple_to_index_nonzero(index_314: IndexTriple) {
        assert_eq!(index_314.to_index(&(2, 0, 1)), 2 * 4 + 1);
    }

    #[rstest]
    fn index_triple_from_index_zero(index_314: IndexTriple) {
        assert_eq!(index_314.from_index(0), Some((0, 0, 0)));
    }

    #[rstest]
    fn index_triple_from_index_nonzero(index_314: IndexTriple) {
        assert_eq!(index_314.from_index(9), Some((2, 0, 1)));
    }

    #[rstest]
    fn index_triple_from_to_index_iter_size(index_314: IndexTriple) {
        testing::check_from_to_index_iter_size(&index_314);
    }

    #[rstest]
    fn index_triple_from_index_invalid(index_314: IndexTriple) {
        testing::check_from_index_invalid(&index_314);
    }

    type UnitSpace = ProductSpace<()>;

    #[test]
    fn unit_from_to_index_iter_size() {
        let space = UnitSpace::new(());
        testing::check_from_to_index_iter_size(&space);
    }

    #[test]
    fn unit_from_index_sampled() {
        let space = UnitSpace::new(());
        testing::check_from_index_sampled(&space, 10);
    }

    #[test]
    fn unit_from_index_invalid() {
        let space = UnitSpace::new(());
        testing::check_from_index_invalid(&space);
    }
}
