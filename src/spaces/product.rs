//! Cartesian product space.
#![allow(clippy::type_complexity)] // Complexity generated by the impl_for_tuples macro
use super::{
    product_subset_ord, ElementRefInto, EncoderFeatureSpace, FiniteSpace, NumFeatures, SampleSpace,
    Space, SubsetOrd,
};
use crate::logging::Loggable;
use impl_trait_for_tuples::impl_for_tuples;
use num_traits::Float;
use rand::distributions::Distribution;
use rand::Rng;
use std::cmp::Ordering;
use std::fmt;
use std::ops::Range;

/// A Cartesian product of spaces.
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
pub struct ProductSpace<T> {
    pub inner_spaces: T,
}

impl<T> ProductSpace<T> {
    /// Initialize from a tuple of spaces.
    pub const fn new(inner_spaces: T) -> Self {
        Self { inner_spaces }
    }
}

impl<T: DisplayForTuple> fmt::Display for ProductSpace<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.inner_spaces.fmt(f)
    }
}

impl<T: SpaceForTuples> Space for ProductSpace<T> {
    type Element = T::Element;

    fn contains(&self, value: &Self::Element) -> bool {
        self.inner_spaces.contains(value)
    }
}

impl<T: SubsetOrdForTuples + PartialEq> SubsetOrd for ProductSpace<T> {
    fn subset_cmp(&self, other: &Self) -> Option<Ordering> {
        self.inner_spaces.subset_cmp(&other.inner_spaces)
    }
}

impl<T: FiniteSpaceForTuples> FiniteSpace for ProductSpace<T> {
    fn size(&self) -> usize {
        self.inner_spaces.size()
    }

    fn to_index(&self, element: &Self::Element) -> usize {
        self.inner_spaces.to_index(element)
    }

    fn from_index(&self, index: usize) -> Option<Self::Element> {
        self.inner_spaces.from_index(index)
    }

    fn from_index_unchecked(&self, index: usize) -> Option<Self::Element> {
        self.inner_spaces.from_index_unchecked(index)
    }
}

impl<T: NumFeaturesForTuples> NumFeatures for ProductSpace<T> {
    fn num_features(&self) -> usize {
        self.inner_spaces.num_features()
    }
}

impl<T: EncoderFeatureSpaceForTuples> EncoderFeatureSpace for ProductSpace<T> {
    type Encoder = T::Encoder;

    fn encoder(&self) -> Self::Encoder {
        self.inner_spaces.encoder()
    }

    fn encoder_features_out<F: Float>(
        &self,
        element: &Self::Element,
        out: &mut [F],
        zeroed: bool,
        encoder: &Self::Encoder,
    ) {
        self.inner_spaces
            .encoder_features_out(element, out, zeroed, encoder)
    }
}

impl<T> Distribution<<Self as Space>::Element> for ProductSpace<T>
where
    T: SpaceForTuples + SampleSpaceForTuples,
{
    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> <Self as Space>::Element {
        self.inner_spaces.sample(rng)
    }
}

impl<T: SpaceForTuples> ElementRefInto<Loggable> for ProductSpace<T> {
    fn elem_ref_into(&self, _element: &Self::Element) -> Loggable {
        // Too complex to log
        Loggable::Nothing
    }
}

// The impl_trait_for_tuples crate helps with implementing traits for tuples.
// I use custom versions of the space traits so that `ProductSpace`
// will only be generic over the tuples defined here.
// Otherwise,
//  * ProductSpace would be generic over any space, not just tuples
//  * Tuples would be interpred as spaces.
//      Could cause confusion given that not typical traits (Distribution) are implemented.
//      Could also cause a tuple of spaces to be accidentally interpreted as a product space.
//
// These have to be listed as public because they are part of the interface of ProductSpace
// but they are not intended to be implemented by user types.

/// Private.
pub trait DisplayForTuple {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result;
}

/// Private. Use [`Space`] instead.
pub trait SpaceForTuples {
    type Element;
    fn contains(&self, value: &Self::Element) -> bool;
}

/// Private. Use [`SubsetOrd`] instead.
pub trait SubsetOrdForTuples {
    fn subset_cmp(&self, other: &Self) -> Option<Ordering>;
}

/// Private. Use [`FiniteSpace`] instead.
pub trait FiniteSpaceForTuples: SpaceForTuples {
    fn size(&self) -> usize;
    fn to_index(&self, element: &Self::Element) -> usize;
    fn from_index(&self, index: usize) -> Option<Self::Element>;
    fn from_index_unchecked(&self, index: usize) -> Option<Self::Element>;
}

/// Private. Use [`NumFeatures`] instead.
pub trait NumFeaturesForTuples {
    fn num_features(&self) -> usize;
}

/// Private. Use [`EncoderFeatureSpace`] instead.
pub trait EncoderFeatureSpaceForTuples: SpaceForTuples + NumFeaturesForTuples {
    type Encoder;
    fn encoder(&self) -> Self::Encoder;
    fn encoder_features_out<F: Float>(
        &self,
        element: &Self::Element,
        out: &mut [F],
        zeroed: bool,
        encoder: &Self::Encoder,
    );
}

/// Private. Use [`Distribution`] instead.
pub trait SampleSpaceForTuples: SpaceForTuples {
    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> <Self as SpaceForTuples>::Element;
}

impl SpaceForTuples for () {
    type Element = ();

    fn contains(&self, _value: &Self::Element) -> bool {
        true
    }
}

#[impl_for_tuples(1, 12)]
#[tuple_types_custom_trait_bound(Space)]
impl SpaceForTuples for Tuple {
    for_tuples!( type Element = ( #( Tuple::Element ),* ); );

    fn contains(&self, value: &Self::Element) -> bool {
        for_tuples!( #( self.Tuple.contains(&value.Tuple) )&* )
    }
}

#[impl_for_tuples(0, 12)]
#[tuple_types_custom_trait_bound(SubsetOrd)]
impl SubsetOrdForTuples for Tuple {
    fn subset_cmp(&self, other: &Self) -> Option<Ordering> {
        let mut state = Ordering::Equal;
        for_tuples!( #(
            state = product_subset_ord(Some(state), self.Tuple.subset_cmp(&other.Tuple))?;
        )* );
        Some(state)
    }
}

impl FiniteSpaceForTuples for () {
    fn size(&self) -> usize {
        1
    }

    fn to_index(&self, _element: &Self::Element) -> usize {
        0
    }

    fn from_index(&self, index: usize) -> Option<Self::Element> {
        if index == 0 {
            Some(())
        } else {
            None
        }
    }

    fn from_index_unchecked(&self, _index: usize) -> Option<Self::Element> {
        Some(())
    }
}

#[impl_for_tuples(1, 12)]
#[tuple_types_custom_trait_bound(FiniteSpace)]
impl FiniteSpaceForTuples for Tuple {
    fn size(&self) -> usize {
        for_tuples!( #( self.Tuple.size() )** )
    }

    fn to_index(&self, element: &Self::Element) -> usize {
        let mut index: usize = 0;
        for_tuples!( #(
            index *= self.Tuple.size();
            index += self.Tuple.to_index(&element.Tuple);
        )* );
        index
    }

    fn from_index(&self, mut index: usize) -> Option<Self::Element> {
        let sizes = [for_tuples!( #( self.Tuple.size() ),* )];
        let mut indices = [for_tuples!(#(0),*)];
        for (index_part, &size) in indices.iter_mut().rev().zip(sizes.iter().rev()) {
            *index_part = index % size;
            index /= size;
        }
        if index != 0 {
            return None;
        }

        let mut indices_iter = indices.into_iter();
        Some(for_tuples!( ( #( self.Tuple.from_index(indices_iter.next().unwrap())? ),* ) ))
    }

    fn from_index_unchecked(&self, mut index: usize) -> Option<Self::Element> {
        self.from_index(index)
    }
}

#[impl_for_tuples(1, 12)]
#[tuple_types_custom_trait_bound(NumFeatures)]
impl NumFeaturesForTuples for Tuple {
    fn num_features(&self) -> usize {
        // The following does not work, so have separate impl for ()
        // for_tuples!( 0 #( + self.Tuple.num_features() )* )
        for_tuples!( #( self.Tuple.num_features() )+* )
    }
}

impl NumFeaturesForTuples for () {
    fn num_features(&self) -> usize {
        0
    }
}

/// Internal hack to work-around limitations in `impl_for_tuples` syntax.
pub trait HasEncoderPart: EncoderFeatureSpace {
    type EncoderPart: EncoderPart<Self::Encoder>;
}
impl<S: EncoderFeatureSpace> HasEncoderPart for S {
    type EncoderPart = (S::Encoder, Range<usize>);
}
/// Internal hack to work-around limitations in `impl_for_tuples` syntax.
pub trait EncoderPart<T> {
    fn encoder(&self) -> &T;
    fn range(&self) -> Range<usize>;
}
impl<T> EncoderPart<T> for (T, Range<usize>) {
    #[inline(always)]
    fn encoder(&self) -> &T {
        &self.0
    }
    #[inline(always)]
    fn range(&self) -> Range<usize> {
        self.1.clone()
    }
}

#[impl_for_tuples(0, 12)]
#[tuple_types_custom_trait_bound(EncoderFeatureSpace)]
impl EncoderFeatureSpaceForTuples for Tuple {
    /// Encoder is a tuple of tuples (inner_encoder, range)
    for_tuples!( type Encoder = ( #( <Tuple as HasEncoderPart>::EncoderPart ),* ); );

    // Impl relies on left-to-right evaluation within a tuple
    #[allow(clippy::eval_order_dependence)]
    #[allow(clippy::unused_unit)] // Generated for size-0 case
    fn encoder(&self) -> Self::Encoder {
        let mut offset = 0;
        for_tuples!( ( #( {
            let size = self.Tuple.num_features();
            let range = offset..(offset + size);
            offset += size;
            (self.Tuple.encoder(), range)
        } ),* ) )
    }

    fn encoder_features_out<F: Float>(
        &self,
        element: &Self::Element,
        out: &mut [F],
        zeroed: bool,
        encoder: &Self::Encoder,
    ) {
        for_tuples!( #(
            self.Tuple.encoder_features_out(
                &element.Tuple,
                &mut out[encoder.Tuple.range()],
                zeroed,
                encoder.Tuple.encoder(),
            );
        )* );
    }
}

impl SampleSpaceForTuples for () {
    fn sample<R: Rng + ?Sized>(&self, _rng: &mut R) -> Self::Element {}
}

#[impl_for_tuples(1, 12)]
#[tuple_types_custom_trait_bound(SampleSpace)]
impl SampleSpaceForTuples for Tuple {
    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::Element {
        for_tuples!( ( #( self.Tuple.sample(rng) ),* ) )
    }
}

#[cfg(test)]
#[allow(clippy::needless_pass_by_value)]
mod space {
    use super::super::{testing, IndexSpace, SingletonSpace};
    use super::*;
    use rstest::{fixture, rstest};

    type IndexTriple = ProductSpace<(IndexSpace, IndexSpace, IndexSpace)>;

    #[fixture]
    const fn index_314() -> IndexTriple {
        ProductSpace::new((IndexSpace::new(3), IndexSpace::new(1), IndexSpace::new(4)))
    }

    #[rstest]
    fn index_triple_contains_zero(index_314: IndexTriple) {
        assert!(index_314.contains(&(0, 0, 0)));
    }

    #[rstest]
    fn index_triple_contains_nonzero(index_314: IndexTriple) {
        assert!(index_314.contains(&(2, 0, 1)));
    }

    #[rstest]
    fn index_triple_contains_samples(index_314: IndexTriple) {
        testing::check_contains_samples(&index_314, 100);
    }

    type UnitSpace = ProductSpace<()>;

    #[test]
    fn unit_contains_unit() {
        let space = UnitSpace::new(());
        assert!(space.contains(&()));
    }

    #[test]
    fn unit_contains_samples() {
        let space = UnitSpace::new(());
        testing::check_contains_samples(&space, 10);
    }

    #[test]
    fn mixed_contains() {
        let space = ProductSpace::new((IndexSpace::new(3), SingletonSpace::new()));
        assert!(space.contains(&(2, ())));
    }

    #[test]
    fn mixed_not_contains_invalid() {
        let space = ProductSpace::new((IndexSpace::new(3), SingletonSpace::new()));
        assert!(!space.contains(&(4, ())));
    }
}

#[cfg(test)]
mod subset_ord {
    use super::super::IntervalSpace;
    use super::*;

    #[test]
    fn empty_eq() {
        assert_eq!(ProductSpace::new(()), ProductSpace::new(()));
    }

    #[test]
    fn empty_partial_cmp_equal() {
        assert_eq!(
            ProductSpace::new(()).subset_cmp(&ProductSpace::new(())),
            Some(Ordering::Equal)
        );
    }

    #[test]
    #[allow(clippy::eq_op)]
    fn same_interval_eq() {
        let s = ProductSpace::new((IntervalSpace::new(0.0, 1.0), IntervalSpace::new(2.0, 3.0)));
        assert_eq!(s, s);
    }

    #[test]
    fn same_interval_cmp_equal() {
        let s = ProductSpace::new((IntervalSpace::new(0.0, 1.0), IntervalSpace::new(2.0, 3.0)));
        assert_eq!(s.subset_cmp(&s), Some(Ordering::Equal));
    }

    #[test]
    fn different_interval_ne() {
        let a = ProductSpace::new((IntervalSpace::new(0.0, 1.0), IntervalSpace::new(2.0, 3.0)));
        let b = ProductSpace::new((IntervalSpace::new(0.0, 1.0), IntervalSpace::new(0.0, 1.0)));
        assert!(a != b);
    }

    #[test]
    fn subset_interval_strict_subset() {
        let a = ProductSpace::new((IntervalSpace::new(0.2, 0.8), IntervalSpace::new(2.2, 2.8)));
        let b = ProductSpace::new((IntervalSpace::new(0.0, 1.0), IntervalSpace::new(2.0, 3.0)));
        assert!(a.strict_subset_of(&b));
    }

    #[test]
    fn partial_subset_interval_strict_subset() {
        let a = ProductSpace::new((IntervalSpace::new(0.2, 0.8), IntervalSpace::new(2.0, 3.0)));
        let b = ProductSpace::new((IntervalSpace::new(0.0, 1.0), IntervalSpace::new(2.0, 3.0)));
        assert!(a.strict_subset_of(&b));
    }

    #[test]
    fn superset_interval_strict_superset() {
        let a = ProductSpace::new((IntervalSpace::new(-0.2, 1.2), IntervalSpace::new(1.8, 3.2)));
        let b = ProductSpace::new((IntervalSpace::new(0.0, 1.0), IntervalSpace::new(2.0, 3.0)));
        assert!(a.strict_superset_of(&b));
    }

    #[test]
    fn mixed_subset_superset_incomparable() {
        let a = ProductSpace::new((IntervalSpace::new(0.2, 0.8), IntervalSpace::new(1.8, 3.2)));
        let b = ProductSpace::new((IntervalSpace::new(0.0, 1.0), IntervalSpace::new(2.0, 3.0)));
        assert!(a.subset_cmp(&b).is_none());
    }
}

#[cfg(test)]
#[allow(clippy::needless_pass_by_value)]
mod finite_space {
    use super::super::{testing, IndexSpace, SingletonSpace};
    use super::*;
    use rstest::{fixture, rstest};

    type IndexTriple = ProductSpace<(IndexSpace, IndexSpace, IndexSpace)>;

    #[fixture]
    const fn index_314() -> IndexTriple {
        ProductSpace::new((IndexSpace::new(3), IndexSpace::new(1), IndexSpace::new(4)))
    }

    #[rstest]
    fn index_triple_size(index_314: IndexTriple) {
        assert_eq!(index_314.size(), 12);
    }

    #[rstest]
    fn index_triple_to_index_zeros(index_314: IndexTriple) {
        assert_eq!(index_314.to_index(&(0, 0, 0)), 0);
    }

    #[rstest]
    fn index_triple_to_index_nonzero(index_314: IndexTriple) {
        assert_eq!(index_314.to_index(&(2, 0, 1)), 2 * 4 + 1);
    }

    #[rstest]
    fn index_triple_from_index_zero(index_314: IndexTriple) {
        assert_eq!(index_314.from_index(0), Some((0, 0, 0)));
    }

    #[rstest]
    fn index_triple_from_index_nonzero(index_314: IndexTriple) {
        assert_eq!(index_314.from_index(9), Some((2, 0, 1)));
    }

    #[rstest]
    fn index_triple_from_to_index_iter_size(index_314: IndexTriple) {
        testing::check_from_to_index_iter_size(&index_314);
    }

    #[rstest]
    fn index_triple_from_index_invalid(index_314: IndexTriple) {
        testing::check_from_index_invalid(&index_314);
    }

    type UnitSpace = ProductSpace<()>;

    #[test]
    fn unit_size() {
        let space = UnitSpace::new(());
        assert_eq!(space.size(), 1);
    }

    #[test]
    fn unit_from_to_index_iter_size() {
        let space = UnitSpace::new(());
        testing::check_from_to_index_iter_size(&space);
    }

    #[test]
    fn unit_from_index_sampled() {
        let space = UnitSpace::new(());
        testing::check_from_index_sampled(&space, 10);
    }

    #[test]
    fn unit_from_index_invalid() {
        let space = UnitSpace::new(());
        testing::check_from_index_invalid(&space);
    }

    type MixedSpace = ProductSpace<(IndexSpace, SingletonSpace)>;

    #[fixture]
    const fn mixed() -> MixedSpace {
        ProductSpace::new((IndexSpace::new(3), SingletonSpace::new()))
    }

    #[rstest]
    fn mixed_size(mixed: MixedSpace) {
        assert_eq!(mixed.size(), 3);
    }

    #[rstest]
    fn mixed_from_to_index_iter_size(mixed: MixedSpace) {
        testing::check_from_to_index_iter_size(&mixed);
    }

    #[rstest]
    fn mixed_from_index_sampled(mixed: MixedSpace) {
        testing::check_from_index_sampled(&mixed, 20);
    }

    #[rstest]
    fn mixed_from_index_invalid(mixed: MixedSpace) {
        testing::check_from_index_invalid(&mixed);
    }
}

#[cfg(test)]
mod base_feature_space {
    use super::super::{IndexSpace, SingletonSpace};
    use super::*;

    #[test]
    fn index_triple_num_features() {
        let space = ProductSpace::new((IndexSpace::new(3), IndexSpace::new(1), IndexSpace::new(4)));
        assert_eq!(space.num_features(), 8);
    }

    #[test]
    fn unit_num_features() {
        let space = ProductSpace::new(());
        assert_eq!(space.num_features(), 0);
    }

    #[test]
    fn mixed_num_features() {
        let space = ProductSpace::new((IndexSpace::new(3), SingletonSpace::new()));
        assert_eq!(space.num_features(), 3);
    }
}

#[cfg(test)]
mod feature_space {
    use super::super::{IndexSpace, SingletonSpace};
    use super::*;

    mod unit {
        use super::*;
        const fn space() -> ProductSpace<()> {
            ProductSpace::new(())
        }

        #[test]
        fn num_features() {
            let space = space();
            assert_eq!(space.num_features(), 0);
        }

        features_tests!(f, space(), (), []);
        batch_features_tests!(b, space(), [(), (), ()], [[], [], []]);
    }

    mod index_triple {
        use super::*;
        const fn space() -> ProductSpace<(IndexSpace, IndexSpace, IndexSpace)> {
            ProductSpace::new((IndexSpace::new(3), IndexSpace::new(1), IndexSpace::new(4)))
        }

        #[test]
        fn num_features() {
            let space = space();
            assert_eq!(space.num_features(), 8);
        }

        features_tests!(
            f,
            space(),
            (1, 0, 2),
            [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0]
        );
        batch_features_tests!(
            b,
            space(),
            [(0, 0, 0), (1, 0, 2)],
            [
                [1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0]
            ]
        );
    }

    mod mixed {
        use super::*;
        const fn space() -> ProductSpace<(IndexSpace, SingletonSpace)> {
            ProductSpace::new((IndexSpace::new(3), SingletonSpace::new()))
        }

        #[test]
        fn num_features() {
            let space = space();
            assert_eq!(space.num_features(), 3);
        }

        features_tests!(f, space(), (0, ()), [1.0, 0.0, 0.0]);
        batch_features_tests!(
            b,
            space(),
            [(0, ()), (2, ())],
            [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]
        );
    }
}
